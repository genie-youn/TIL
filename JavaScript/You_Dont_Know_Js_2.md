# You Don't Know Js - 2



# 1. this 와 객체 프로토타입 



## 1. this 라나 뭐라나 



this 는 함수 스코프내에 자동으로 설정된다. 



### 1.1 this 를 왜? 



명시적인 파라미터로 컨텍스트를 넘기는 것 보다 객체 레퍼런스를 암묵적으로 함께 넘기는 ‘this’ 체계가 API 설계상 더 깔끔한 코드를 만들고 재사용성이 나을때가 많다. 

객체와 프로토타입을 배우고 나면 더 명확히 느낄것 



### 1.2 헷갈리는 것들 



사람들은 보통 this를 두가지로 오해를 많이한다. 함수객체 자기 자신과, 함수의 스코프 



#### 1.2.1 자기 자신 



자기참조는 물론 필요하다. 재귀호출을 해야 할 때라던지 이벤트 최초 호출시 바인딩된 함수 자기 자신을 언바인딩 할때라던지, 그렇지만 this 는 그럴때 쓰기위한게 아니다. 



예로 

```javascript
function foo (num) { 
    console.log(num);
    this.count++; 
} 

foo.count = 0; 

for (var i = 0 ; i < 10 ; i++) { 
    if (i > 5) { 
        foo(i); 
    } 
} 
```



를 하면 출력은 5번 되지만 count 는 0이다. 

엄한 전역객체의 count가 생겼는데 심지어 이시점에 얘의 값은 NaN 이된다.. 



단순히 이걸 회피하기 위해 var data = { count : 0 } 이런 외부 객체를 만드는건 너무 임시방편이고 

이런 이름이 있는 함수는 렉시컬 스코프에 의해 자신의 이름으로 찾을 수 있지만 (foo.count++) 익명함수는 이럴 방법도 없다. 



arguments.callee 로 호출 가능하나 이건 비표준이 되었으니 쓰지말자



아니면 this 가 foo 객체를 가르키도록 this 바인딩을 한다. 

foo.call(foo, i); 



#### 1.2.2 자신의 스코프 



두번째로 많이 하는 오해가 함수가 참조하는 스코프로 이해하는 것인데 이것도 땡이다. 



스코프 “객체” 는 자바스크립트 구현체인 “엔진” 의 일부로 일반 자바스크립트 코드로는 참조할 수 없다. 

this 와 렉시컬 스코프사이의 연결통로 따위는 존재하지 않는다. 



### 1.3 this 란 무엇인가. 



this 는 작성 시점이 아닌 런타임 시점에 바인딩 되며, 함수 호출 당시 상황에 따라 컨텍스트가 결정된다. 함수 선언과 상관없이 어떻게 함수를 호출했는가가 결정짓는다. 



어떤 함수를 호출하면 활성화 레코드, 즉 실행 환경이 만들어지고 이 실행 환경에는 호출된 근거와 (콜스택), 호출 방법, 전달된 인자등의 정보가 담기는데 this 레퍼런스는 이들중 하나이다. 함수가 실행되는 동안 살이있다. 



## 2. this가 이런 거로군!



### 2.1 호출부



this 의 바인딩 객체를 알려면 함수의 호출부를 알아야한다.

생각보다 호출부를 찾는게 쉽지 않은 경우가 있는데, 이때 중요한건 호출스택을 잘 확인하는것. 함수의 호출부는 현재 실행중인 함수 직전의 호출코드 내부에 있다.



#### 2.2.1 기본 바인딩



함수 단독 실행



나머지 규칙에 해당하지 않을 경우 적용되는 this 바인딩 기본 규칙이다.

이때 엄격모드일 경우 undefined가 비엄격 모드일 경우 전역객체가 바인딩 되고 엄격모드는 호출부가 아닌 함수 본문이 엄격모드여야 한다.



#### 2.2.2 암시적 바인딩



호출부에 컨텍스트 객체가 있는지 확인한다. 즉 객체의 함수 레퍼런스 소유 / 포함 여부를 확인한다.



```javascript
function foo() {
	console.log(this.a);
}

var obj = { 
	a : 42;
	foo : foo;
} 

obj.foo(); // 2 
```



obj가 실제로 foo 를 갖고 있는건 아니지만 (함수 레퍼런스를 참조할 뿐) obj.foo() 의 호출부에서 obj 라는 컨텍스트를 통해 접근하기 때문에 함수 레퍼런스를 소유/포함 한다고 할 수 있다. 이땐 이 obj 가 this 에 바인딩 된다. 



체이닝 될때는 맨 마지막 객체를 참조한다. 



##### 암시적 소실 



소실되면 기본 규칙을 따른다.  

```javascript
function foo() { 
	console.log(this.a);
} 

var obj = { 
	a : 2,
	foo : foo
} 



var a = “ㅎㅎ”; 

var bar = obj.foo; 

bar() // “ㅎㅎ”; 
```



var bar = obj.foo 는 foo() 를 가르키는 또다른 레퍼런스를 갖는다. obj.foo 를 가르키는게 아니라 (js는 변수끼리 참조할 수 있는 방법따윈 존재하지 않는다) 

그래서 그냥 foo() 한것과 마찬가지. 그래서 기본규칙을 탄다. 



#### 2.2.3 명시적 바인딩 



call() , apply() 메소드를 사용한다. 

두 메서드는 this에 바인딩할 객체를 첫번째 파라미터로 받아 함수 호출시 이 객체를 this 에 명시적으로 바인딩 한다. 

원시값을 넘기면 박싱된다. 



##### 하드 바인딩 



자주 사용하는 패턴이라 `Function.prototype.bind` 로 추가되었다. 

얘는 기존 함수에 파라미터로 받은 객체가 하드바인딩된 함수를 반환한다. (무조건 `this` 를 이 파라미터로 바인딩한) 



##### API 호출 컨텍스트 



`Array.prototype.forEach` 처럼 `this` 를 자동으로 바인딩해주는 것 



#### 2.2.4 new 바인딩 



흔히 오해들 하는데 자바스크립트에서 `new` 연산자는 의미상 클래스 지향적인 기능의 생성자와 아무런 상관이 없다..



자바스크립트의 생성자는 `new` 연산자가 있을 때 호출되는 일반 함수에 불가하다. 

클래스에 붙은것도 아니고 클래스를 인스턴스화 하지도 않는다. 



생성자 호출시 다음과 같은 일이 자동으로 일어난다. 



1. 새 객체가 툭 만들어진다. 
2. 새로 생성된 객체의 `[[Prototype]]` 을 연결한다. 
3. 새로 생성된 객체는 함수 호출시 `this` 로 바인딩 된다. 
4. 이 함수가 자신의 또다를 객체를 반환하지 않는 한 `new` 와 함께 호출된 함수는 방금 생성된 객체를 반환한다. 



### 2.3 모든일은 순서가 있는 법 



`new` 바인딩 -> 명시적 바인딩 -> 암시적 바인딩 -> 기본 바인딩 순으로 적용된다. 



`new` 바인딩으로 하드 바인딩을 오버라이딩 하려는 이유는 뭘까? 

함수 인자를 전부 또는 일부만 미리 셋팅하기위해 -> 커링 

`bind()` 함수는 최초 `this` 바인딩 이후 전달된 인자를 원함수의 기본인자로 고정하는 역할을 한다. 

`bind()`의 두번째 인자부터가 `new` 의 인자 보다 먼저 인자로 잡힌다. 



```javascript
function foo (p1, p2) { 
	this.val = p1 + p2;
} 



var bar = foo.bind(null, “p1”); 
var baz = new bar(“p2”); 
baz.val; // p1p2 
```



#### 2.3.1 this 확정 규칙 



1. `new` 함수로 호출했는가? -> 새로 생성된 객체가 `this`다 
2. `apply`, `call`, `bind` 로 호출했는가? -> 명시적으로 지정된 객체가 `this`다
3. 함수를 컨텍스트, 즉 소유하거나 포함하는 형태로 호출 했는가? -> 이 컨텍스트 객체가` this` 다 
4. 그 외의 경우에는 기본값으로 바인딩된다. 



### 2.4 바인딩 예외 



규칙엔 예외가 있다. 



#### 2.4.1 this 무시 



`call`, `apply`, `bind` 메서드에 첫번째 인자로 `null` 혹은 `undefined` 를 넘기면 `this` 바인딩은 무시되고 기본바인딩 규칙이 적용된다. 

왜 `null` 같은 값으로 `this` 바인딩을 하려 하냐면 다음 두가지다 



```javascript
function foo (a,b) { 
	console.log(“a:” + a + “, b :” + b);
} 

foo.apply(null, [1,2]); // a: 2, b: 3 배열을 넣으면 파라미터로 폃쳐진다 / es6부터 …(Spread Operation) 으로 대체가능하다 foo(…[1,2]) 

var bar = foo.bind(null, [1,2]); // 커링한다. 아직 대체할 연산자는 존재하지 않는다. 
bar (3); // a : 2, b : 3 
```



