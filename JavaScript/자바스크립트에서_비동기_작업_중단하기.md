# 자바스크립트에서 비동기 작업 중단하기

## 들어가며
자바스크립트에서 Fetch 요청을 중단시킬 수 있는 AbortController 에 대해 소개하고, 이를 응용하여 비동기 태스크를 중단시키는 방법을 기술한 [Aborting a signal: How to cancel an asynchronous task in JavaScript](https://ckeditor.com/blog/Aborting-a-signal-how-to-cancel-an-asynchronous-task-in-JavaScript/) 을 번역하고 약간의 설명을 덫붙이려 한다.

## 전문
비동기 작업은 다루기 까다롭다. 더욱이 실수로 시작되거나 더 이상 필요없는 비동기 작업에 대하여 중단할 수 있는 방법을 제공하지 않는 몇몇 프로그래밍 언어에서는 더 까다롭게 느껴진다. 다행히도, 자바스크립트에서는 비동기 작업들을 손쉽게 중단할 수 있는 방법을 제공한다.

### Abort signal
The need to cancel asynchronous tasks emerged shortly after introducing Promise into ES2015 and the appearance of several Web APIs supporting the new asynchronous solution. The first attempt focused on creating a universal solution that could later become a part of the ECMAScript standard. However, discussions quickly became stuck without solving the problem. Due to that WHATWG prepared their own solution and introduced it directly into the DOM in the form of AbortController. The obvious downside of such resolution is the fact that AbortController is not available in Node.js, leaving this environment without any elegant or official way to cancel asynchronous tasks.

`Promise` 가 ES2015를 통해 표준 스펙에 포함되고 몇몇 Web API 들이 이 새로운 비동기 해결책을 지원하기 시작하자 중간에 [비동기 작업을 취소해야 하는 필요성](https://github.com/whatwg/fetch/issues/27)이 대두되었다. 이 문제를 해결하기 위한 첫번째 시도는 추후 [ECMAScript의 표준 스펙으로 포함될 수 있는 범용적인 해결책](https://github.com/tc39/proposal-cancellation)을 만드는데 초점을 두었다. 하지만 얼마가지 못해 문제를 해결하지 못한채 논의가 중단되었다.

그 후 WHATWG는 독자적인 준비한 해결책인 [`AbortController` 를 DOM에 도입](https://dom.spec.whatwg.org/#aborting-ongoing-activities)한다. 그렇기 때문에 이 `AbortController` 는 Node.js 환경에선 사용할 수 없기 때문에 명백한 단점을 가지고 있다고 할 수 있다.

As you can see in the DOM specification, AbortController is described in a very general way. Thanks to this you can use it in any kind of asynchronous APIs — even ones that do not exist yet. At the moment only Fetch API officially supports it, but nothing stops you from using it inside your own code!

But before jumping to it, let us spend a moment analyzing how AbortController works:

DOM 스펙문서에서 확인할 수 있듯, `AbortController` 는 몹시 범용적으로 설계되어 있다. 덕분에 현재는 `Fetch API` 만이 공식적으로 지원하지만 어떤 비동기 API에도 (심지어 아직 존재하지 않는 API 일지라도) 사용가능하다.

그럼 `AbortController` 가 어떻게 동작하는지 잠시 살펴보도록 하자.

```javascript
const abortController = new AbortController(); // 1
const abortSignal = abortController.signal; // 2

fetch( 'http://example.com', {
  signal: abortSignal // 3
} ).catch( ( { message } ) => { // 5
  console.log( message );
} );

abortController.abort(); // 4
```

Looking at the code above you can see that at the beginning, you create a new instance of the AbortController DOM interface (1) and bind its signal property to a variable (2). Then you invoke fetch() and pass signal as one of its options (3). To abort fetching the resource you just call abortController.abort() (4). It will automatically reject the promise of fetch() and the control will be passed to the catch() block (5).

위의 코드를 보면, 우선 `AbortController` DOM 인터페이스의 새로운 인스턴스를 만든 후 (1), 인스턴스의 `signal` 프로퍼티를 (2) `fetch` 의 `signal` 옵션에 할당하는 것을 볼 수 있다. (3)

패칭을 중단하기 위해서는 단순히 `abortController.abort()` 를 호출하기만 하면 된다. (4) `abort` 를 호출하게 되면 `fetch` 의 Promise 는 자동으로 `reject` 되게 되고 제어는 `catch()` 블럭으로 진입하게 된다. (5)


The signal property itself is quite interesting and it is the main star of this show. The property is an instance of the [AbortSignal DOM interface](https://dom.spec.whatwg.org/#interface-AbortSignal) that has an aborted property with information whether the user has already invoked the abortController.abort() method. You can also bind the abort event listener to it that will be called when abortController.abort() is called. In other words: AbortController is just a public interface of AbortSignal.

이 흥미로운 `signal` 프로퍼티가 가장 주요한 부분이다. 이 프로퍼티는 사용자가 이미 `abortController.abort()` 메소드를 호출했는지 여부에 대한 정보를 나타내는 `aborted` 프로퍼티를 가진  [AbortSignal DOM interface](https://dom.spec.whatwg.org/#interface-AbortSignal) 의 인스턴스이다. 또한 `abortController.abort()` 가 호출될때 발생하는 `abort` 이벤트에 리스너를 등록할 수 있다. 즉, `AbortController` 는 단지 `AbortSignal` 의 퍼블릭 인터페이스일 뿐이다.

### Abortable function

Let us imagine that you have an asynchronous function that does some very complicated calculations (for example, it asynchronously processes data from a big array). To keep it simple, the sample function will be simulating the hard work by waiting five seconds before returning the result:

매우 복잡한 연산을 하는 비동기 함수(예를들어 굉장히 큰 배열을 비동기적으로 처리하는 함수) 가 있다고 상상해보자. 예제를 간단하게 하기 위해 5초동안 복잡한 연산을 하고 가정하고, 5초 뒤에 결과를 반환하는 함수로 대체한다.

```javascript
function calculate() {
  return new Promise( ( resolve, reject ) => {
    setTimeout( ()=> {
      resolve( 1 );
    }, 5000 );
  } );
}

calculate().then( ( result ) => {
  console.log( result );
} );
```

However, sometimes the user would want to abort such a costly operation. And rightly so — they should have such an ability. Add a button that will start and stop the calculation:

그리고 이 비용이 큰 연산을 중간에 취소하고 싶은 사용자들을 위해 연산을 시작하고, 중단할 수 있는 버튼을 추가하자.

```javascript
<button id="calculate">Calculate</button>

<script type="module">
  document.querySelector( '#calculate' ).addEventListener( 'click', async ( { target } ) => { // 1
    target.innerText = 'Stop calculation';

    const result = await calculate(); // 2

    alert( result ); // 3

    target.innerText = 'Calculate';
  } );

  function calculate() {
    return new Promise( ( resolve, reject ) => {
      setTimeout( ()=> {
        resolve( 1 );
      }, 5000 );
    } );
  }
</script>
```

In the code above you add an asynchronous click event listener to the button (1) and call the calculate() function inside it (2). After five seconds the alert dialog with the result will appear (3). Additionally, script[type=module] is used to force JavaScript code into strict mode — as it is more elegant than the 'use strict' pragma.

위의 코드를 보면 우선, 버튼의 `click` 이벤트에 리스너를 비동기적으로 등록한다. (1) 이 리스너는 `calculate()` 를 호출하게 된다. (2) 5초가 지난 후 결과를 표시하는 알럿이 노출되게 된다. (3)

Now add the ability to abort an asynchronous task:

이제 비동기작업을 취소하는 기능을 추가해보자.

```javascript
{ // 1
  let abortController = null; // 2

  document.querySelector( '#calculate' ).addEventListener( 'click', async ( { target } ) => {
    if ( abortController ) {
      abortController.abort(); // 5

      abortController = null;
      target.innerText = 'Calculate';

      return;
    }

    abortController = new AbortController(); // 3
    target.innerText = 'Stop calculation';

    try {
      const result = await calculate( abortController.signal ); // 4

      alert( result );
    } catch {
      alert( 'WHY DID YOU DO THAT?!' ); // 9
    } finally { // 10
      abortController = null;
      target.innerText = 'Calculate';
    }
  } );

  function calculate( abortSignal ) {
    return new Promise( ( resolve, reject ) => {
      const timeout = setTimeout( ()=> {
        resolve( 1 );
      }, 5000 );

      abortSignal.addEventListener( 'abort', () => { // 6
        const error = new DOMException( 'Calculation aborted by the user', 'AbortError' );

        clearTimeout( timeout ); // 7
        reject( error ); // 8
      } );
    } );
  }
}
```

As you can see, the code has become much longer. But there is no reason to panic — it has not become much harder to understand!

코드가 훨씬 더 길어졌지만, 당황하지 말고 천천히 들여다 보도록 하자. 아마 쉽게 이해할 수 있을 것이다.

Everything is enclosed inside the block (1), which is an equivalent of IIFE. Thanks to this, the abortController variable (2) will not leak into the global scope.

모든 코드는 블럭으로 감싸져 있고 (1) 이는 마치 [IIFE (즉시 실행 함수)](https://exploringjs.com/es6/ch_core-features.html#sec_from-iifes-to-blocks) 와 같은 효과를 갖는다. 이 덕분에 `abortController` 변수를 전역 스코프로 불필요하게 노출하지 않을 수 있다. (2)

At first, you set its value to null. This value changes at the mouse click on the button. Then you set its value to a new instance of AbortController (3). After that, you pass the instance’s signal property directly to your calculate() function (4).

우선 이 값을 `null` 로 초기화한다. 이 값은 버튼을 마우스로 클릭하면 `AbortController` 의 새로운 인스턴스로 바뀌게 된다. (3) 이후 인스턴스의 `signal` 프로퍼티를 `calculate()` 함수에 인자로 전달하게 된다. (4)

If the user clicks the button again before five seconds elapsed, it will cause the invocation of the abortController.abort() function (5). This, in turn, will fire the abort event on the AbortSignal instance you passed earlier to calculate() (6).

사용자가 5초가 지나기 전에 버튼을 다시 클릭하면, `abortController.abort()` 를 호출하게 된다. (5)  이것은 다시 `calculate()` 에 인자로 전달했던 `AbortSignal` 인스턴스의 `abort` 이벤트를 발생시키게 된다. (6)

Inside the abort event listener you remove the ticking timer (7) and reject the promise with an appropriate error (8; according to the specification it must be a DOMException with an 'AbortError' type). The error eventually passes control to catch (9) and finally blocks (10).

You should also prepare your code to handle a situation like this:



AbortSignal 스펙에 좀 더 자세한 내용?
Axios 에서 요청을 중단하기
