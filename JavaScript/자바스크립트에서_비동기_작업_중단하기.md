# 자바스크립트에서 비동기 작업 중단하기

## 들어가며
자바스크립트에서 Fetch 요청을 중단시킬 수 있는 AbortController 에 대해 소개하고, 이를 응용하여 비동기 태스크를 중단시키는 방법을 기술한 Aborting a signal: How to cancel an asynchronous task in JavaScript 을 번역하고 약간의 설명을 덫붙이려 한다.

## 전문
비동기 작업은 다루기 까다롭다. 더욱이 실수로 시작되거나 더 이상 필요없는 비동기 작업에 대하여 중단할 수 있는 방법을 제공하지 않는 몇몇 프로그래밍 언어에서는 더 까다롭게 느껴진다. 다행히도, 자바스크립트에서는 비동기 작업들을 손쉽게 중단할 수 있는 방법을 제공한다.

### Abort signal
The need to cancel asynchronous tasks emerged shortly after introducing Promise into ES2015 and the appearance of several Web APIs supporting the new asynchronous solution. The first attempt focused on creating a universal solution that could later become a part of the ECMAScript standard. However, discussions quickly became stuck without solving the problem. Due to that WHATWG prepared their own solution and introduced it directly into the DOM in the form of AbortController. The obvious downside of such resolution is the fact that AbortController is not available in Node.js, leaving this environment without any elegant or official way to cancel asynchronous tasks.

`Promise` 가 ES2015를 통해 표준 스펙에 포함되고 몇몇 Web API 들이 이 새로운 비동기 해결책을 지원하기 시작하자 중간에 [비동기 작업을 취소해야 하는 필요성](https://github.com/whatwg/fetch/issues/27)이 대두되었다. 이 문제를 해결하기 위한 첫번째 시도는 추후 [ECMAScript의 표준 스펙으로 포함될 수 있는 범용적인 해결책](https://github.com/tc39/proposal-cancellation)을 만드는데 초점을 두었다. 하지만 얼마가지 못해 문제를 해결하지 못한채 논의가 중단되었다.

그 후 WHATWG는 독자적인 준비한 해결책인 [`AbortController` 를 DOM에 도입](https://dom.spec.whatwg.org/#aborting-ongoing-activities)한다. 그렇기 때문에 이 `AbortController` 는 Node.js 환경에선 사용할 수 없기 때문에 명백한 단점을 가지고 있다고 할 수 있다.

As you can see in the DOM specification, AbortController is described in a very general way. Thanks to this you can use it in any kind of asynchronous APIs — even ones that do not exist yet. At the moment only Fetch API officially supports it, but nothing stops you from using it inside your own code!

But before jumping to it, let us spend a moment analyzing how AbortController works:

DOM 스펙문서에서 확인할 수 있듯, `AbortController` 는 몹시 범용적으로 설계되어 있다. 덕분에 현재는 `Fetch API` 만이 공식적으로 지원하지만 어떤 비동기 API에도 (심지어 아직 존재하지 않는 API 일지라도) 사용가능하다.

그럼 `AbortController` 가 어떻게 동작하는지 잠시 살펴보도록 하자.

```javascript
const abortController = new AbortController(); // 1
const abortSignal = abortController.signal; // 2

fetch( 'http://example.com', {
  signal: abortSignal // 3
} ).catch( ( { message } ) => { // 5
  console.log( message );
} );

abortController.abort(); // 4
```

Looking at the code above you can see that at the beginning, you create a new instance of the AbortController DOM interface (1) and bind its signal property to a variable (2). Then you invoke fetch() and pass signal as one of its options (3). To abort fetching the resource you just call abortController.abort() (4). It will automatically reject the promise of fetch() and the control will be passed to the catch() block (5).

위의 코드를 보면, 우선 `AbortController` DOM 인터페이스의 새로운 인스턴스를 만든 후 (1), 인스턴스의 `signal` 프로퍼티를 (2) `fetch` 의 `signal` 옵션에 할당하는 것을 볼 수 있다. (3)

패칭을 중단하기 위해서는 단순히 `abortController.abort()` 를 호출하기만 하면 된다. (4) `abort` 를 호출하게 되면 `fetch` 의 Promise 는 자동으로 `reject` 되게 되고 제어는 `catch()` 블럭으로 진입하게 된다. (5)


The signal property itself is quite interesting and it is the main star of this show. The property is an instance of the [AbortSignal DOM interface](https://dom.spec.whatwg.org/#interface-AbortSignal) that has an aborted property with information whether the user has already invoked the abortController.abort() method. You can also bind the abort event listener to it that will be called when abortController.abort() is called. In other words: AbortController is just a public interface of AbortSignal.


AbortSignal 스펙에 좀 더 자세한 내용?
