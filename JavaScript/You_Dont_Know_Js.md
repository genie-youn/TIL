# You Don't Know Js



##1 타입 



EcmaSacript 의 언어 타입은 undefined, null, number, string, object, boolean, symbol 이 존재한다. 



### 1.1 타입 그 실체를 이해하자 



coercion -> 타입 강제 변환 



### 1.2 내장 타입 



null 은 type이 object 이다. 

falsy 하고 type이 object 인지 체크해야 null 체크 가능하다. 

typeof 의 결과물로 나오는 function 은 object 의 하위 타입이다. 

함수 = 호출 가능한 [내부적인 call 프로퍼티로] object 

배열은 몇가지 특성 (length 가 자동으로 생성된다든지) 하는 object 의 특이한 하위타입 



### 1.3 값은 타입을 가진다 



js 의 변수에는 타입이 없다. 변수가 갖는 값에만 타입이 존재하며 typeof 는 이 변수에 들어있는 값의 타입은? 으로 해석해야한다. 



#### 1.3.1 값이 없는 vs 선언되지 않은 



값이 없는 변수의 값은 undefined 이다. 

undefined 와 is not declare 는 명확히 다르지만 typeof 를 때리면 둘다 undefined 이다. 

직접 사용하면 ReffereceError 를 뱉는다. 

이는 typeof 의 safe-guard 이다. 전역변수 체크를 위한.. 



#### 1.3.2 선언되지 않은 변수 



존재하지 안흔 기능을 추가하기위해 폴리필을 정의하려면 

atob 선언문에서 var를 빼라 



그 이유는 코드실행 (if 문)을 건너뛰어도 선언 자체가 최상위 스코프로 호이스팅 되면서 특수한 타입의 전역변수 (호스트 객체 window) 가 중복선언되어 예외를 뱉는다. 



typeof 안쓰려면 window.~ 로 해도 되는데 (선언되지 않은 객체의 어떤 프로퍼티로 접근할때는 선언되지 않아도 예외 안뱉음) 권장하진 않는다. 



### 1.4 1장 정리 



js 에는 7가지 타입 (null, undefined, number, string, boolean, object, symbol) 이 존재 

변수에는 타입이 없고 변수가 갖는 값에만 타입이 있다. 

js 에서 `undefined` 와 `undeclare` 는 명확히 다르지만 typeof 의 결과는 둘다 undefined 이다. 



## 2. 값 



### 2.1 배열 



js 에서 배열은 어떤 타입의 값이든 담을수 있다. 빈 슬롯은 혼란을 일으키고, typeof를 때리면 undefined 가 나올것같지만 명시적으로 undefined 를 주는것과는 좀 다르다 



배열 인덱스는 숫자인데, 배열 자체도 객체여서 문자열의 키/밸류 설정 가능. 근데 이 키가 숫자로 강제 형변환되면 인덱스로 인식… 그니까 쓰지마라 



#### 2.1.1 유사배열 



유사배열값 (숫자 인덱스가 가르키는 값들의 집합) 은 Array.prototype.slice() 를 쓰거나 es6 부터는 Array.from() 을 쓰면 간단하다. 



### 2.2 문자열 



문자열은 유사배열이 배열은 아니다. 

문자열은 불변 , 배열은 가변 



### 2.3 숫자 



자바 스크립트의 숫자 타입은 Number 가 전부이며 정수는 소수점이 없는 부동소수점 타입과 같다… 



#### 2.3.1 숫자 리터럴 



strcik mode?



#### 2.3.2 작은 소수값 



부동 소수점이 소수점이 많이 낮은 수를 정확하게 표현하지 못한다. 이를 머신 입실론이라고 하고, es6 부터 Number.EPSILON 으로 정의. 값은 2^-52 이것보다 오차가 적으면 같다고 봐야 한다. 

즉 0.1 + 0.2 === 0.3 이 성립안한다. 



#### 2.3.3 안전한 정수 범위 



Number.MAX_VALUE > Number.MAX_SAFE_INTEGER .. 왜 안전범위지?.. 53비트로 9조 정도된다,.

그래서 64비트 ID 는 표현 불가능 문자열로 받던지 빅인티져 라이브러리를 쓰던지 



#### 2.3.5 32비트 (부호있는) 정수 



안전범위가 53비트 9조정도 인데 (비트연산자등) 몇몇 연산자는 32비트 숫자에만 가능하다. 

그 결과로 

a | 0 하면 32비트 정수형으로 강제 형변환 되는 효과를 갖는다 | 비트 연산이 32비트에만 가능해서 32비트 상위비트는 전부 버려버리고 OR 0 이 마치 NOOP 연산과 같은 효과가 있기 때문 



### 2.4 특수값 



#### 2.4.1 값 아닌 값 



undefined 타입의 값은 undefined, null 의 타입의 값은 null 근데 undfined는 재정의 가능 



void 연산자 



void ~ 는 항상 결과값은 undefined 로 만든다. 사용할곳이 극히 적기하다. 



#### 2.4.3 특수문자 



NaN 의 타입은 Number다.. 

NaN 은 그 어떤 NaN 과도 동등하지 않다. 심지어 자기 자신조차도. 반사성이 없는 유일무이한 존재 

값으로 내장 전역 유틸리티인 isNaN() 메소드가 있는데 이건 모든 숫자가 아닌걸 판단해서.. (스트링이라던지) es6 부터는 Number.isNaN() 이 생겼다. 



무한대 



무한 / 무한 = NaN 



-0 



-0이 존재하는 이유는 방향등 메타정보를 남겨두기 위해서 

근데 -0 -> 문자열 하면 -는 손실되고 0과 동등한 취급을 받는 이상한 점이 있다. 



#### 2.4.4 특이한 동등 비교 

NaN은 자기 자신과 동등하지 x 

-0은 0과 동등한척 하기 때문에 폴리필을 심어주던지 

ES6 부터 제공하는 Object.is() 를 사용하던지. 



### 2.5 값 vs 레퍼런스 



js에서는 어떤 변수가 다른 변수를 참조할 방법은 없다. 

js 에서 레퍼런스는 공유된 값을 가르키므로 서로 다른 10개의 레퍼런스가 있다면 이들은 저마다 항상 공유된 단일값을 개별적으로 참조한다. 



값 또는 레퍼런스 할당 및 전달에 대한 syntax-hint 가 없이 값의 타입에 따라 엔진이 결정하는데 

null, undefined, string, number, boolean 은 스칼라 값이 복사되고 

object, function, array 는 레퍼런스 전달 



객체를 값 복사하기 위해선 slice() / 값을 레퍼복사하려면 래퍼를 쓸것 -> 그러나 Number, String 등은 내부적으로 불변값을 가지므로 Object로 래핑해야한다.  