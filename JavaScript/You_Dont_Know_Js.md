# You Don't Know Js



##1 타입 



EcmaSacript 의 언어 타입은 undefined, null, number, string, object, boolean, symbol 이 존재한다. 



### 1.1 타입 그 실체를 이해하자 



coercion -> 타입 강제 변환 



### 1.2 내장 타입 



null 은 type이 object 이다. 

falsy 하고 type이 object 인지 체크해야 null 체크 가능하다. 

typeof 의 결과물로 나오는 function 은 object 의 하위 타입이다. 

함수 = 호출 가능한 [내부적인 call 프로퍼티로] object 

배열은 몇가지 특성 (length 가 자동으로 생성된다든지) 하는 object 의 특이한 하위타입 



### 1.3 값은 타입을 가진다 



js 의 변수에는 타입이 없다. 변수가 갖는 값에만 타입이 존재하며 typeof 는 이 변수에 들어있는 값의 타입은? 으로 해석해야한다. 



#### 1.3.1 값이 없는 vs 선언되지 않은 



값이 없는 변수의 값은 undefined 이다. 

undefined 와 is not declare 는 명확히 다르지만 typeof 를 때리면 둘다 undefined 이다. 

직접 사용하면 ReffereceError 를 뱉는다. 

이는 typeof 의 safe-guard 이다. 전역변수 체크를 위한.. 



#### 1.3.2 선언되지 않은 변수 



존재하지 안흔 기능을 추가하기위해 폴리필을 정의하려면 

atob 선언문에서 var를 빼라 



그 이유는 코드실행 (if 문)을 건너뛰어도 선언 자체가 최상위 스코프로 호이스팅 되면서 특수한 타입의 전역변수 (호스트 객체 window) 가 중복선언되어 예외를 뱉는다. 



typeof 안쓰려면 window.~ 로 해도 되는데 (선언되지 않은 객체의 어떤 프로퍼티로 접근할때는 선언되지 않아도 예외 안뱉음) 권장하진 않는다. 



### 1.4 1장 정리 



js 에는 7가지 타입 (null, undefined, number, string, boolean, object, symbol) 이 존재 

변수에는 타입이 없고 변수가 갖는 값에만 타입이 있다. 

js 에서 `undefined` 와 `undeclare` 는 명확히 다르지만 typeof 의 결과는 둘다 undefined 이다. 



## 2. 값 



### 2.1 배열 



js 에서 배열은 어떤 타입의 값이든 담을수 있다. 빈 슬롯은 혼란을 일으키고, typeof를 때리면 undefined 가 나올것같지만 명시적으로 undefined 를 주는것과는 좀 다르다 



배열 인덱스는 숫자인데, 배열 자체도 객체여서 문자열의 키/밸류 설정 가능. 근데 이 키가 숫자로 강제 형변환되면 인덱스로 인식… 그니까 쓰지마라 



#### 2.1.1 유사배열 



유사배열값 (숫자 인덱스가 가르키는 값들의 집합) 은 Array.prototype.slice() 를 쓰거나 es6 부터는 Array.from() 을 쓰면 간단하다. 



### 2.2 문자열 



문자열은 유사배열이 배열은 아니다. 

문자열은 불변 , 배열은 가변 



### 2.3 숫자 



자바 스크립트의 숫자 타입은 Number 가 전부이며 정수는 소수점이 없는 부동소수점 타입과 같다… 



#### 2.3.1 숫자 리터럴 



strcik mode?



#### 2.3.2 작은 소수값 



부동 소수점이 소수점이 많이 낮은 수를 정확하게 표현하지 못한다. 이를 머신 입실론이라고 하고, es6 부터 Number.EPSILON 으로 정의. 값은 2^-52 이것보다 오차가 적으면 같다고 봐야 한다. 

즉 0.1 + 0.2 === 0.3 이 성립안한다. 



#### 2.3.3 안전한 정수 범위 



Number.MAX_VALUE > Number.MAX_SAFE_INTEGER .. 왜 안전범위지?.. 53비트로 9조 정도된다,.

그래서 64비트 ID 는 표현 불가능 문자열로 받던지 빅인티져 라이브러리를 쓰던지 



#### 2.3.5 32비트 (부호있는) 정수 



안전범위가 53비트 9조정도 인데 (비트연산자등) 몇몇 연산자는 32비트 숫자에만 가능하다. 

그 결과로 

a | 0 하면 32비트 정수형으로 강제 형변환 되는 효과를 갖는다 | 비트 연산이 32비트에만 가능해서 32비트 상위비트는 전부 버려버리고 OR 0 이 마치 NOOP 연산과 같은 효과가 있기 때문 



### 2.4 특수값 



#### 2.4.1 값 아닌 값 



undefined 타입의 값은 undefined, null 의 타입의 값은 null 근데 undfined는 재정의 가능 



void 연산자 



void ~ 는 항상 결과값은 undefined 로 만든다. 사용할곳이 극히 적기하다. 



#### 2.4.3 특수문자 



NaN 의 타입은 Number다.. 

NaN 은 그 어떤 NaN 과도 동등하지 않다. 심지어 자기 자신조차도. 반사성이 없는 유일무이한 존재 

값으로 내장 전역 유틸리티인 isNaN() 메소드가 있는데 이건 모든 숫자가 아닌걸 판단해서.. (스트링이라던지) es6 부터는 Number.isNaN() 이 생겼다. 



무한대 



무한 / 무한 = NaN 



-0 



-0이 존재하는 이유는 방향등 메타정보를 남겨두기 위해서 

근데 -0 -> 문자열 하면 -는 손실되고 0과 동등한 취급을 받는 이상한 점이 있다. 



#### 2.4.4 특이한 동등 비교 

NaN은 자기 자신과 동등하지 x 

-0은 0과 동등한척 하기 때문에 폴리필을 심어주던지 

ES6 부터 제공하는 Object.is() 를 사용하던지. 



### 2.5 값 vs 레퍼런스 



js에서는 어떤 변수가 다른 변수를 참조할 방법은 없다. 

js 에서 레퍼런스는 공유된 값을 가르키므로 서로 다른 10개의 레퍼런스가 있다면 이들은 저마다 항상 공유된 단일값을 개별적으로 참조한다. 



값 또는 레퍼런스 할당 및 전달에 대한 syntax-hint 가 없이 값의 타입에 따라 엔진이 결정하는데 

null, undefined, string, number, boolean 은 스칼라 값이 복사되고 

object, function, array 는 레퍼런스 전달 



객체를 값 복사하기 위해선 slice() / 값을 레퍼복사하려면 래퍼를 쓸것 -> 그러나 Number, String 등은 내부적으로 불변값을 가지므로 Object로 래핑해야한다.  



## 3.네이티브 



네이티브는 ECMAScript 명세상의 내장 객체이다 



String() / Number() / Boolean() / Array() / Object() / Function() / RegExp() / Date() / Error() / Symbol()  

new String(“abc”) 는 원시값을 감싼 객체래퍼로 typeof 를 때리면 object 이다 



### 3.1 내부 [[Class]] 



typeof가 Object 인 값에는 내부 [[Class]] 프로퍼티가 존재하고 대부분 내장 네이티브 생성자를 가르키지만 아닌 경우도 있다. -> null, undefined 는 존재, 나머지는 박싱 [object String]  이렇게 된다. 



### 3.2 래퍼 박싱하기 



브라우저는 오랜기간 이걸 스스로 최적화 해놧다. 개발자가 선 최적하를 하면 오히려 성능이 하락될 수 있다. 

그냥 원시값을 쓸것 



#### 3.2.1 객체 래퍼의 함정 



new Boolean(false) 는 true.. new Boolean 이 강제로 true로 형변환한다. 수동으로 값을 박싱하려면 Object() 메소드를 쓸것.. 



#### 3.3.3 언박싱 



언박싱할땐 valueOf() 쓰면됨 



### 3.4 네이티브. 나는 생성자다. 



#### 3.4.1 Array() 



빈슬롯의 배열을 만드려고 난리치지 말것. 정말 많은 문제가 생긴다. map 이 제대로 안돈다던지.. 혼란스럽기도하고 

정말 쓰려면 Array.apply(null, {length: 3}) 이런식으로 



#### 3.4.2 Object(), Function(), RegExp() 



Object() 는 장점이 없다 쓰지마라 

Function()은 동적으로 인자나 바디를 생성할거 아니면 쓰지마라. 그럴일 거의 없다 

RegExp() 는 리터럴로 하면 성능이점이 크다. 하지만 동적으로 패턴을 만들어 내는건 은근 쓸일이 많다. 

new RegExp(“패턴”, “플래그”) 로 써라 



#### 3.4.3 Date(), Error() 



이 둘은 리터럴이 없어서 써야만 한다. 

Error의 주 용도는 현재의 실행 콘텍스틀 객체에 담아 디버깅에 유용한 정보를 얻는것 



#### 3.4.4 Symbol() 



Symbol() ES6에 추가된 키워드로 ES6 의 특수한 내장 로직을 사용하기 위해 고안 되었으나 재정의 가능하다. 

충돌 없이 객체 프로퍼티로 사용 가능한 특별한 유일값 -> 내부적으로 사용하는 프로퍼티에 관습적으로 사용하는 언더스코어를 대체하게 될꺼라는데 왜지? 무슨장점이 있길래



객체가 아니라 원시값이다. 얘의 프로퍼티들은. ????????? 이게 맞나?



#### 3.4.5 네이티브 프로토타입 



네이티브는 내장객체들이므로 .prototype 도 당연히 존재 하고 이 프로토타입에는 타입별로 고유한 로직이 담겨있다. 그러니까 (확장이 아닌) 재정의하는 짓은 지양할것 



프로토타입 위임? prototype delegation 뭔소리지



프로토 타입은 해당 객체의 디폴트다 -> 빈 배열, 빈함수, 빈정규식 등등.. 

그래서 디폴트로 var vals = vlas || String.prototype 이렇게 쓰면 prototype 은 한번만 생성되므로 성능상 이점이 존재하나, 만약 vals 의 값이 바뀌면 영향을 준다. 그니까 read-only 에서만 쓸것 



es6 에서는 디폴트값이 신텍스로 가능하다;. 



### 3.5 정리하기 



js 에서는 스칼라 원시값을 감쌀수 있는 객체 래퍼를 제공하는데 이를 네이티브라고한다. 네이티브 프로토타입엔 타입별로 유용한 메소드들이 미리 정의되어 있다. 



원시값에 이 메소드들을 바로 호출하면 자동으로 객체로 감싸는데 이를 박싱이라고 한다. 



## 4. 강제변환 



자바스크립트 엔진에 의해 타입이 자동으로 바뀌는것 



### 4.1 값 변환 



강제변환이란 어떤 값을 다른타입의 (원시) 값으로 변경하는것. 이걸 명시적 강제변환은 캐스팅, 암묵적 강제변환은 강제변환 concerion  



값 -> 객체로 바꾸는 박싱은 엄밀히 말하면 묵시적 강제변환이 아니다. -> 왜지? 



### 4.2 추상 연산 (Abstract Operation) 



내부적으로 어떻게 다른타입으로 값을 바꿀지 정의해 놓은 메소드 



#### 4.2.1 ToString 



Object.prototype.toString() 을 기본적으로 호출하며 흔히 알듯 “” 를 감싸서 바꾼다. toString()이 재정의 되어 있으면 그걸 호출 



여기서 JSON.stringify 는 직렬화, 문자열화와는 조금 다르며, 다른 언어에서 사용할 수 없는 타입인 undefined, null 같은 애들은 자동으로 누락 (undefined) 배열사이에 껴있으면 인덱스를 유지하기위해 null 을 때려박고 객체의 프로퍼티는 삭제 



호출한 객체의 toJSON() 을 호출하는데 이걸 많이 헷갈려한다. 얘는 JSON 의 쓸 문자열을 만드는게 아니라 JSON - 안전 객체를 만듬 (순환참조 객체를 없앤다거나..) 그래서 객체를 리턴해야해 



여기서 몇가지 팁은 두번째 인자로 배열이나 함수를 주어서 프로그램틱하게 이걸 걸러낼 수 있고, 세번째인자로 들여쓰기 정도 주기 가능 



대신 함수를 주면 처음엔 객체 자기 자신을 가지고 이 함수를 돌림, 다음부턴 프로퍼티와 그 값을 키밸류로 던짐 



#### 4.2.2 ToNumber 



숫자가 아닌 값 -> 숫자 

true -> 1 / false -> 0 / undefined -> NaN / null -> 0 



객체 & 배열은 ToPrimitive 추상연산을 돌려 원시값으로 바꾼 후 위 로직을 돌리는데 

valueOf 메소드가 존재하면 이걸로, 없으면 toString() 으로 둘다 안되면 TypeError 를 뱉ㅌ는다. 



#### 4.2.3 ToBoolean 



제일 노답이다. 

자바 스크립트의 모든값은 이 두가지로 나눌 수 있다. 

1 강제변환시 false가 되는 값 

2 1을 제외한 나머지 전부 



1 을 falsy 한 값이라고 하는데 다음과 같다 

undefined 

null 

+0 -0 NaN 

false 

“” 



이외에는 몽땅 강제변환하면 true 이다 값은 



##### falsy 객체 



이건또 뭔소리냐 객체는 전부 true 라면서. 물론 falsy 를 갖는 래퍼 객체도 true 다. 

falsy 객체는 순수 자바스크립트 객체는 아니다. 



예를 보면 이해가 빠른데 document.all 이라는 아이가 있었는데 얘는 비표준이다. 이미 오래전에 비권장 / 폐기되었다. 이 document.all 을 불리언으로 강제변환한 결과값을 if 문등으로 오래된, 비표준 IE 브라우저를 감지하는 수단으로 사용해왔다. 그래서 이걸 걷어낼수 없게 되었고 대신 표준을 준수하는 자바스크립트에서 이걸 false를 뱉게 해서 이 로직이 적용안되게 한것.. 맙소사 

이런 아이들을 falsy 객체라고 한다. 



## 5. 문법 



### 5.1 문과 표현식 



자바스크립트는 문 statement 와 표현식 expression 을 철저하게 구분한다. 

문은 문장 sentece, 표현식은 구문 phase, 연산자는 구두점 / 접속사 정도라고 할 수 있겟다. 



자바스크립트에서 표현식은 단일한, 특정한 결과값을 가진다. 

var a = b * c; 가 있을 때 b * c 는 표현식 a = b * c 는 할당 표현식 이 문장 전체는 선언문이 된다. 



#### 5.1.1 문의 완료 값 



모든 문은 심지어 undefined 도 완료 값을 갖는다. 

개발자 도구에서 콘솔은 가장 최근의 문의 완료값을 표시한다. 



블록의 완료값은 내부에 있는 마지막 문의 완료값을 암묵적으로 반환하는데, 개발자가 이 값을 잡아서 쓸 방법은 없다. eval() 로 가능하긴한데.. 그런짓은 하지말자 do 라는 키워드가 제안된 상태이다. 



#### 5.1.2 문의 부수효과 



문의 결과값을 반환하는것 외에 다른 곳에 영향 (변경) 을 가하는것 

대입문은 자체가 부수효과다 a = 42 일 때 42를 반환하는게 결과값 a 에 42이란 값을 입력하는것 자체가 부수효과 

이거 잘 활용하면 코드를 많이 간결하게 표현할 수 있다. 



#### 5.1.3 컨텍스트 규칙 



같은 문이 컨텍스트에 따라 다르게 작동하는것 

예를 들면 중괄호인데 중괄호는 네가지로 동작할 수 있다. 



1 객체 리터럴 

2 레이블 (break 나 continue 에서 레이블 점프를 쓰기위한) 

3 블록 

4 객체 디스트럭쳐링 



tip json 과 jsonp 에 대하여  

json 형식으로 되어 있는 파일을 통채로 불러올수 없다. 레이블로 인식해서 레이블에 쌍따옴표를 쓸수 없기 때문에 이걸 스크립트에 함수들 중 하나의 인자로 넘겨서 사용하면 객체 리터럴로 인식해서 쓸 수 있다. 이런 패턴을 json-p 라고 한다. 접근 할 수 없는 파일에 접근할 수 있게 하는게 아니라 자바스크립트가 이해할 수 있게 json에 옷을 입히는 거랄까 



\[ ] + { } 에선 { } 가 빈 객체로 인식되서 [object, Object] 

{ } + \[ ] 에선 { } 가 빈 블럭으로 인식되서 0 



js에 else if 문은 존재하지 않는다. 표준스타일에는 위배되지만 관습처럼 사용한다. 



### 5.2 연산자 우선순위 



자바스크립트에서 && || 은 피연산자중 하나를 선택해서 반환한다 미친 

여러 문을 잇는 , 는 제일 낮은 우선순위 

&& 은 || 보다 먼저 

|| 은 3항보다 먼저 

= 은 , 직전으로 낮다 



#### 5.2.1 단락평가 



&& 이나 || 의 경우 왼쪽의 피연산자로 전체의 결과를 결정지을 수 있을때 오른쪽 피연산자는 계산조차 안함 

이걸 유용하게 사용하면 개꿀 



#### 5.2.3 결합성 



보통은 왼쪽 결합인데 3항 연산이나 = 는 오른쪽 결합 



### 5.3 세미콜론 자동 삽입 ASI 



파서에러를 넘기기 위해 엔진이 추론해서 세미콜론을 넣어주는데, 문법에 맞춰서 코드를 짜는게 낫지 않을까?



### 5.4 에러 



early-error 는 컴파일 시점에 반환하는 에러. 코드 자체가 실행되지 않기 때문에 try-catch 로 잡히지 않는다. 구문은 문제없으나 문법적으로 말이 안되는 경우  

42 = a 이런거.. 엄격모드에선 더 많다. 근데 이름이 syntax-error 임 



#### 5.4.1 너무 이른 변수사용 



es6 에는 임시 데드 존 TDZ Temporal Dead Zone 이란게 추가됨 

TDZ 는 아직 초기화 하지 않아 변수를 참조할 수 없는 코드 영역 

블럭 스코프 내 let 키워드에서 발견 할 수 있는데 

```javascript
{ 
    a = 42;   // ReferenceError 
	let a;   // 이제서야 a 가 TDZ 에서 나와 undefined가 할당된다 
} 
```



참조할수 없는 영역에 있으니 typeof도 안된다 당연 

```javascript
{ 
	typeof a; // undefined 
	typeof b; // ReferenceError 
	let a; 
} 
```







### 5.5 함수 파라미터 

TDZ 는 함수 디폴트 파라미터에서도 발견 가능 

```javascript
function(a = 4, b = a + b + 1) { 

} 
```



왜냐하면 이 디폴트 파라미터가 왼쪽에서 오른쪽으로 let 으로 선언된다. 

b = a + b + 1 에서 b를 참조하는데 이 b 는 아직 선언이 덜 끝나서 TDZ 내부에 존재 ReferenceError 



디폴트 파라미터의 입장에선 값이 있는지 없는지 상관없지만  

arguments 입장에선 차이가 크다 명시적으로 undefined 를 넘기면 undefined 로 arguments 슬롯을 채움 

arguments 와 파라미터간 불일치가 생김 



비단 es 6에서만의 문제는 아닌데 

```javascript
function link (a) { 
	a = 42;     
	console.log(arguments[0]); 
} 
```



a 가 존재할때 a에 값을 넘기면 a 와 arguments[0] 은 연결되서 같이 42가 되지만 

값을 안넘기면 연결이 끊겨서 a만 42가 된다. 



arguments 배열은 비권장 사항이 되었지만 (구멍난 추상화) 

es6 의 등장 전에는 파라미터를 배열로 받을 유일한 방법. 

파라미터와 파라미터에 해당하는 arguments 슬롯을 섞어쓰지만 않는다면 아직도 쓸만 하다. 



### 5.6 try-finally 



try 에 return 이나 throw 가 존재하면 finally 의 로직을 전부 처리하고 반환된다. 

try {} 에서 반환값 결정 finally {} 로직 수행 결정된 값 반환 이런 로직 

그래서 finally 에서 throw 를 하게 되면 앞의 값은 사장되어 버린다. 

```javascript
for (var i = 0 ; i < 10 ; i++){ 
	try {
		continue;
	} finally {
		console.log(i);
	}
} 
```



를 돌리면 0….9 가 출력되는걸 알수있는데 한 iteration 이 끝나기 전에 (continue 가 반환되기 전에) finally 블럭이 실행된다는걸 알 수 있다. 



return 도 마찬가지. 다만 자바스크립트에서 함수에 return 이 없을 경우 return undefined 로 인식하지만 당연히 finally 에선 try 에서의 반환값을 존중한다. 



### 5.7 switch 



switch 에 값을 써두면 엄격한 비교를 한다 (===) 

강제변환에 의한 느슨한 비교를 하려면 다음과 같이 작성 



```javascrip
var a = “42”; 
switch(true) { 
	case a == 42 : 
}  
```



근데 case 의 평가 표현식이 true 가 아닌 truthy 라면 비교를 제대로 못하는데 

```javascript
var a = “hello word”; 
var b = 10; 

swtich (true) { 
	case (a || b == 10) : // 절대 안들어옴 a || b == 10 의 결과는 “hello word” 다..
} 
```



그래서 이런 트릭으로 해결 가능하다. 흠.. 

```javascript
swtich (true) { 
	case !!(a || b == 10) : // 절대 안들어옴 a || b == 10 의 결과는 “hello word” 다.. 
} 
```



