# 브라우저의 캐시 매커니즘

## 들어가며
BFF서버와 CDN을 처음 구축하고 운영하면서 단순히 static file 들을 서빙하면 되지~ 하는 생각을 다시하게 되었다. 은근히 많은 비용을 차지하고 많은 요청을 받아내야 했으며, 막연히 '어차피 브라우저 캐시 탈꺼니까~' 라고 여기며 정작 브라우저 캐시가 정확히 어떤 매커니즘으로 동작하는지 잘 모르고 있었다는 사실을 알게 되었다. 분명 캐시를 타는 것 같은데, 요청량이 왜 이렇게 많은것 같지? 하면서도 정확한 동작 방법을 모르니 많이 답답했어서 이기회에 한판 정리하려 한다.

## 브라우저 캐시?
캐싱은 리소스의 복사본을 저장소에 저장해 두고 요청 시 이를 서빙하는 기술을 통칭한다. 데이터를 불러오는 비용을 줄이기 위함인데, 브라우저에서 캐싱이라 함은 HTTP 요청을 브라우저가 저장해두고, 이후 같은 요청이 발생한다면 서버에 요청하는 대신 이를 서빙함으로써 성능을 향상시키는 방법이다.

## 대상
일반적으로 브라우저 캐싱의 대상이 될 수 있는 것은 다음과 같다
- GET 요청의 성공한 결과: HTML 문서를 포함한 이미지, 정적 리소스 파일에 대한 `GET` 요청이 성공했을 때 이 결과를 캐싱할 수 있다.
- 영구적인 리다이렉트: `301` 응답
- 페이지를 찾을 수 없음: `404` 응답
- 완전하지 않음: `206` (부분적인 컨텐츠) 응답
- 캐시 키로 사용하기에 적절한 무언가가 정의된 경우의 `GET` 이외의 응답 (?)

## 캐시 제어
HTTP/1.1 스펙에서 요청/응답측 모두 `Cache-Control` 헤더를 사용하여 캐시를 제어할 수 있다.

### 캐시하지 않음
```
Cache-Control: no-store
Cache-Control: no-cache, no-store, must-revalidate
```

### 캐시하지만 재검증
```
Cache-Control: no-cache
```

> no-cache는 모든 요청에 대하여 이 캐시를 사용해도 될지 서버에 검증을 받고, must-revalidate는 만료된 캐시에 대하여 이 캐시를 사용해도 될지 서버에 검증을 받고 no-store는 캐시를 저장하지 못하게 한다.
> 의미만 보자면 no-store만 주면 되는것이 아닌가
> 흠..https://stackoverflow.com/questions/49547/how-do-we-control-web-page-caching-across-all-browsers/2068407#2068407


### Public 캐시와 Private 캐시
`public` 캐시는 응답이 어떤 캐시에 의해서든 캐싱됨
`private` 캐시는 단일 사용자를 위한것이며, 공유캐시에는 캐싱되면 안됨. 브라우저는 private 캐시이므로 이를 캐싱할 수 있다.

> 왜 필요한건지

```
Cache-Control: private
Cache-Control: public
```

### 만료
```
Cache-Control: max-age=31536000
```

### 검증
```
Cache-Control: must-revalidate
```

### Pragma 헤더
`Pragma` 헤더는 HTTP/1.0 헤더로 `Cache-Control` 헤더를 대체하여 사용할 수 있을 정도의 신뢰성은 제공하지 못한다.
> ?

그러므로 HTTP/1.0 과의 호환성을 유지하려는 경우에만 `Pragma` 헤더를 사용해야 한다.

## 유효성
기본적으로 캐시는 특정 시간동안 유효하게 되고, 이 시간이 만료된다면 서버에 해당 컨텐츠의 변경이 있는지 확인하는데, 변경이 없다면 서버는 대역폭을 줄이기 위해 `304 Not Modified` 응답을 내리게 된다. 이 응답을 받고 나면 캐시의 유효시간을 다시 갱신하게 된다.

유효수명은 몇가지 헤더에 의해 결정된다. 우선 `Cache-control: max-age=N` 헤더가 있는지 확인하고 이 헤더가 존재한다면 캐시의 수명은 `N` 만큼 유지된다. 만약 이 헤더가 없다면 다음으로는 `Expires` 헤더를 참조하게 된다. 이 헤더가 존재한다면, 이 값에서 `Date` 값을 뺀 결과가 캐시의 유효수명이 된다.

만약 이 헤더도 없다면 마지막으로, `Last-Modified` 헤더를 참조하게 된다. 이 역시 `Date` 에서 `Last-modified` 의 값을 뺀 뒤 10으로 나눈 결과가 캐시의 유효시간이 된다.

캐시의 만료시간은 이 유효시간을 기준으로 다음과 같이 계산할 수 있다.

```
expirationTime = responseTime + freshnessLifetime - currentAge
```

## 활성화된(Revved) 리소스
캐시를 통해 성능을 높이는 방법은 캐시의 만료시간을 길게 가져가는 것이다. 하지만 이는 파일이 갱신이 필요해졌을 때 난감해 질 수 있는데, 이를 해결하기 위한 방법이 Steve Sounders 가 고안해낸 `revving` 이다.

요점은 파일을 갱신하지 않고 새로 만드는것. 기존의 리소스는 계속 캐시되도록 두고 파일에 변경사항이 생기면 새로운 파일을 만들어 서빙한다. 파일명에 버전을 붙인다던지, 해시를 만들어 붙인다던지 하는 방식으로. 이렇게 하면 캐시의 효과는 극대화 할 수 있지만 리소스 파일과의 연결을 전부 새로운 파일을 바라보게 바꿔주어야 한다는 단점이 존재한다.

요즘 대부분의 프론트엔드 개발은 이 방식으로 청크를 나누어서 청크에 빌드 해시를 붙이는 식으로 캐시를 태우는것 같다.

## 캐시 검증
재 검증은 사용자가 새로고침을 눌렀을 경우 촉발되며, `Cache-control:must-revalidate` 로 설정되거나 개발자도구에서 캐시사용을 강제로 off 한 경우에도 발생한다. 캐시의 만료시간이 가까워지면 문서가 검증되거나 새로 불러와진다. 검증은 서버에서 *강한 검증* 이나 *약한 검증* 을 제공하는 경우에만 일어날 수 있다.

### ETags
https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/ETag

### Last-Modified
https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Last-Modified

> 이 둘은 추가 정리 필요

## 상황에 따른 응답
`Vary` 헤더를 사용하여 특정한 상황에서만 캐시를 사용하게 할 수 있다. `Vary` 헤더에 명시한 헤더가 일치해야지만 동일한 캐시를 서빙하게 된다.
예를 들어 `Vary: User-Agent` 로 설정을 해 두면 데스크톱에서 요청했었던 파일을 모바일에서 요청한다고 하더라도 이전 요청으로 캐시해 두었던 파일을 서빙하지 않고 서버로부터 새로운 파일을 받아 서빙하게 된다.
