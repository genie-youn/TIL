# 브라우저의 캐시 매커니즘

## 들어가며
BFF서버와 CDN을 처음 구축하고 운영하면서 단순히 static file 들을 서빙하면 되지~ 하는 생각을 다시하게 되었다. 은근히 많은 비용을 차지하고 많은 요청을 받아내야 했으며, 막연히 '어차피 브라우저 캐시 탈꺼니까~' 라고 여기며 정작 브라우저 캐시가 정확히 어떤 매커니즘으로 동작하는지 잘 모르고 있었다는 사실을 알게 되었다. 분명 캐시를 타는 것 같은데, 요청량이 왜 이렇게 많은것 같지? 하면서도 정확한 동작 방법을 모르니 많이 답답했어서 이기회에 한판 정리하려 한다.

## 브라우저 캐시?
캐싱은 리소스의 복사본을 저장소에 저장해 두고 요청 시 이를 서빙하는 기술을 통칭한다. 데이터를 불러오는 비용을 줄이기 위함인데, 브라우저에서 캐싱이라 함은 HTTP 요청을 브라우저가 저장해두고, 이후 같은 요청이 발생한다면 서버에 요청하는 대신 이를 서빙함으로써 성능을 향상시키는 방법이다.

## 대상
일반적으로 브라우저 캐싱의 대상이 될 수 있는 것은 다음과 같다
- GET 요청의 성공한 결과: HTML 문서를 포함한 이미지, 정적 리소스 파일에 대한 `GET` 요청이 성공했을 때 이 결과를 캐싱할 수 있다.
- 영구적인 리다이렉트: `301` 응답
- 페이지를 찾을 수 없음: `404` 응답
- 완전하지 않음: `206` (부분적인 컨텐츠) 응답
- 캐시 키로 사용하기에 적절한 무언가가 정의된 경우의 `GET` 이외의 응답 (?)

## 캐시 제어
HTTP/1.1 스펙에서 요청/응답측 모두 `Cache-Control` 헤더를 사용하여 캐시를 제어할 수 있다.

### 캐시하지 않음
```
Cache-Control: no-store
Cache-Control: no-cache, no-store, must-revalidate
```

> 무슨 차이지

### 캐시하지만 재검증
```
Cache-Control: no-cache
```

> 이 헤더가 있어야 변경없음을 내리는건가

### Public 캐시와 Private 캐시
`public` 캐시는 응답이 어떤 캐시에 의해서든 캐싱됨
`private` 캐시는 단일 사용자를 위한것이며, 공유캐시에는 캐싱되면 안됨. 브라우저는 private 캐시이므로 이를 캐싱할 수 있다.

> 왜 필요한건지

```
Cache-Control: private
Cache-Control: public
```

### 만료
```
Cache-Control: max-age=31536000
```

### 검증
```
Cache-Control: must-revalidate
```

### Pragma 헤더
`Pragma` 헤더는 HTTP/1.0 헤더로 `Cache-Control` 헤더를 대체하여 사용할 수 있을 정도의 신뢰성은 제공하지 못한다.
> ?

그러므로 HTTP/1.0 과의 호환성을 유지하려는 경우에만 `Pragma` 헤더를 사용해야 한다.
