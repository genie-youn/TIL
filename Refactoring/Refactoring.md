## 1. 맛보기 예제

### 1.1 리팩토링 첫단계

리팩토링의 첫 단계는 리팩토링할 대상 코드에 대해 신뢰도 높은 테스트를 구현하는것

리팩토링은 uml 과 interaction diagram 과 함께

성능은 문제가 될 때 개선하자. 깨끗한 코드가 먼저다.

간단한 수정과 테스트의 싸이클을 반복하며 개발할것



## 2. 리팩토링 개론

### 2.1 리팩토링은 무엇인가?

두가지로 정의하겠다.

1. 겉으로 드러나는 기능은 그대로 둔 채, 알아보기 쉽고 수정하기 쉽게 소프트웨어 내부를 수정하는것
2. 리팩토링 기법을 연달아 적용해서 겉으로 드러나는 기능은 그대로 둔 채 소프트웨어 구조를 변경한다.

#### 모자두개

켄트 백은 ‘모자 두개’ 라는 비유를 들었다. 기능을 추가할 땐 기능에만, 리팩토링을 할 땐 리팩토링에만 전념할 것

### 2.2 리팩토링은 왜 해야하나

1. 소프트웨어 설계가 개선되니까
2. 소프트웨어를 이해하기가 더 쉬워지니까
3. 버그를 찾기 쉬워지니까
4. 프로그래밍 속도가 빨라지니까

### 2.3 리팩토링은 어떨때 필요한가?

1. 같은 작업의 삼진 아웃일 때
2. 기능을 추가할 때

3. 버그를 수정할 때 

4. 코드를 검수할 때 



### 2.4 팀장에게 어떻게 말을 꺼내지? 



정 안되면 몰래해라ㅋㅋ 



### 2.5 리팩토링 관련 문제들 



1. 데이터베이스 

2. 인터페이스 변경 

3. 리팩토링을 어렵게 하는 설계를 수정하는 일 

4. 리팩토링을 하면 안되는 상황 



### 2.6 리팩토링과 설계 



간단한 솔루션을 구현해 놓고 그걸 나중에 유연한 솔루션으로 리팩토링 하려면 얼마나 수고가 들까? 를 고민해보고 웬만한 경우철머 별 어려움이 없을 것 같다면 간단한 솔루션을 구현하자. 심플한게 최고 



### 2.7 리팩토링과 성능 



리팩토링을 통해 프로그램을 잘 쪼개면 성능 튜닝에 할애할 시간이 생기고 성능을 분석할 때 더 정밀한 분석이 가능해져 길게보면 성능향상에 도움을 준다. 

단기적으로 소프트웨어가 느려지지만, 최적화를 거치면서 튜닝하기 훨씬 쉬워져 결과적으로는 소프트웨어 개발이 더 빨라진다. 



## 3. 코드의 구린내 



### 3.1 중복코드 



메서드 추출 / 메서드 상향 / 템플릿 메소드 형성 / 알고리즘 전환 / 주변 메소드 추출 / 클래스 추출 / 모듈 추출 



### 3.2 장황한 메소드 



메소드 추출 / 임시 변수를 메소드 호출로 전환 / 임시 변수를 메소드 체인으로 전환 / 매개변수를 세트 객체로 전환 / 객체를 통채로 전달 / 메소드를 메소드 객체로 전환 / 조건문 쪼개기 / 루프를 컬렉션 클로저 메소드로 전환 



### 3.3 방대한 클래스 



클래스 추출 / 하위 클래스 추출 / 모듈 추출 / 인터페이스 추출 



### 3.4 과다한 매개변수 



매개변수 세트를 메소드로 전환 / 객체를 통째로 전달 / 매개변수 세트를 객체로 전환 



### 3.5 수정의 산발 



한 클래스가 다양한 원인 때문에 다양한 방식으로 자주 수정될 때 -> 객체를 분리 



### 3.6 기능의 산재 



하나의 수정이 생길때마다 여러 클래스에서 수많은 자잘한 부분을 고쳐야 할 때. 수정의 산발과는 비슷하지만 정 반대다 



### 3.7 잘못된 소속 



객체의 핵심은 데이터와 그 데이터에 사용되는 프로세스를 한 데 묶는 기술 메서드 이동 / 메서드 추출 



### 3.8 데이터 뭉치 



데이터 뭉치를 클래스로 추출 한 뒤 매개변수 세트를 객체로 전환 / 객체를 통째로 전달 



### 3.9 강박적 기본 타입 사용 



데이터값을 객체로 전환 / 분류부호를 클래스 (하위클래스)로 전환 / 분류부호를 상태/전략 패턴으로 변환 



### 3.10 switch 문 



`switch` 문은 고민할 것 없이 다형성을 통한 재정의로 바꿔야한다. 



### 3.11 평행 상속 계층 



### 3.12 직무유기 클래스 



계층병합 / 클래스내용 직접 삽입 / 모듈 내용 직접 삽입 



### 3.13 막연한 범용 코드 



메서드나 클래스가 오로지 테스트 케이스에만 사용되고 있다면 의심해볼것 



### 3.14 임시필드 



객체안에 어떤 인스턴스 변수가 특정 상황에만 할당될 때 이는 헷갈림을 유발한다. 



### 3.15 메세지 체인 



대리객체 은폐 



### 3.16 과인 중개 메서드 



과잉 중개 메서드 제거 / 메서드 내용 직접 삽입 / 위임을 상속으로 변경 



### 3.17 지나친 관여 



메서드 이동 / 필드 이동 / 양방향 연결을 단방향으로 변경 / 클래스 추출 / 대리 객체 은폐 / 상속을 위임으로 전환 



### 3.18 인터페이스가 다른 대용 클래스 



### 3.19 미흡한 라이브러리 클래스 



외래클래스에 메소드 추가 / 국소적 상속 확장 클래스 사용 



### 3.20 데이터 클래스 



컬렉션 캡슐화 / 쓰기 메서드 제거 



### 3.21 방치된 상속물 



### 3.22 불필요한 주석 



어선셜 넣기 / 주석을 넣어야겠다는 생각이 들면 리팩토링을 통해 주석을 없앨 수는 없을지 고민해볼것 



## 4. 테스트 작성 



리팩토링을 실시하기 위한 전제조건은 반드시 견고한 테스트를 작성하는 것이다. 



### 4.1 자가 테스트의 가치 



테스트를 작성하기 가장 적합한 시점 중 하나는 프로그래밍을 시작할 때다. 

기능을 추가할 때는 우선 테스트 코드부터 작성하자. 왠지 순서가 뒤바뀐것 같지만 그렇지 않다. 

테스트를 작성하면 그 기능을 추가하려고 해야 할 작업이 무엇인지 자문하게 된다. 그리고 테스트를 작성하면 구현부가 아니라 인터페이스에 집중하게 된다. 



### 4.2 JUnit 테스트 프레임워크 



단위테스트는 생산성 향상이, 기능 테스트는 품질 보장이 목적이다. 



### 4.3 테스트 추가 



완벽한 테스트를 작성하려다 테스트를 포기하느니, 불완전한 테스트를 적당히 실행해라. 

잘못될 수 있는 경계조건을 생각한 뒤, 그 상황의 테스트에 집중해라 

뭔가 에러가 있으리라 예상될 때, 그 예외가 정말로 발생하는지 꼭 확인해라.



## 5. 리팩토링 기법 카탈로그에 대해



## 6. 메서드 정리



리팩토링의 주된 작업은 코드를 포장하는 메서드를 적절히 정리하는 것이다. 거의 모든 문제점은 장황한 메서드로 인해 생긴다. 장황한 메서드에는 많은 정보가 들어 있는데, 마구 얽힌 복잡한 로직에 이 정보들이 묻혀버린다. 핵심적인 리팩토링 기법은 코드 뭉치를 별도의 메소드로 빼내는 메서드 추출이다. 그와 반대로 메서드 내용 직접 삽입은 개별 메서드로 빼내고 보니 그렇게 만들어진 일부 메서드가 제 역할을 못하거나 그 메서드들을 쪼갠 방식을 바꿔야 할 때는 메소드 내용 직접 삽입 기법을 적용해야 한다.



### 6.1 메서드 추출 Extract Method



어떤 코드를 그룹으로 묶어도 되겠다고 판단될 땐 그 코드를 빼내어 목적을 잘 나타내는 직관적 이름의 메서드로 만들자.



```java
void printOwing(double amount) {
    printBanner();
    
    System.out.println("name:" + _name);
    System.out.println("amount:" + amount);
}
```



```java
void printOwing(double amount) {
    printBanner();
    printDetails(amount);
}

void printDetails(double amount) {
    System.out.println("name:" + _name);
    System.out.println("amount:" + amount);
}
```



#### 동기 

메서드가 너무 길거나 코드에 주석을 달아야만 의도를 이해할 수 있을 때

간결한 메서드가 좋은 이유는 세가지.

1. 다른 메서드에서 쉽게 사용할 수 있다.
2. 상위 계층에 메서드에서 주석 같은 더 많은 정보를 읽어들일 수 있다.
3. 재정의하기에 훨씬 수월하다.

 메서드 내용이 간결한 것도 중요하지만, 효과를 보려면 메서드 이름도 잘 지어야 한다.

