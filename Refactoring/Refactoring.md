## 1. 맛보기 예제

### 1.1 리팩토링 첫단계

리팩토링의 첫 단계는 리팩토링할 대상 코드에 대해 신뢰도 높은 테스트를 구현하는것

리팩토링은 uml 과 interaction diagram 과 함께

성능은 문제가 될 때 개선하자. 깨끗한 코드가 먼저다.

간단한 수정과 테스트의 싸이클을 반복하며 개발할것



## 2. 리팩토링 개론

### 2.1 리팩토링은 무엇인가?

두가지로 정의하겠다.

1. 겉으로 드러나는 기능은 그대로 둔 채, 알아보기 쉽고 수정하기 쉽게 소프트웨어 내부를 수정하는것
2. 리팩토링 기법을 연달아 적용해서 겉으로 드러나는 기능은 그대로 둔 채 소프트웨어 구조를 변경한다.

#### 모자두개

켄트 백은 ‘모자 두개’ 라는 비유를 들었다. 기능을 추가할 땐 기능에만, 리팩토링을 할 땐 리팩토링에만 전념할 것

### 2.2 리팩토링은 왜 해야하나

1. 소프트웨어 설계가 개선되니까
2. 소프트웨어를 이해하기가 더 쉬워지니까
3. 버그를 찾기 쉬워지니까
4. 프로그래밍 속도가 빨라지니까

### 2.3 리팩토링은 어떨때 필요한가?

1. 같은 작업의 삼진 아웃일 때
2. 기능을 추가할 때

3. 버그를 수정할 때 

4. 코드를 검수할 때 



### 2.4 팀장에게 어떻게 말을 꺼내지? 



정 안되면 몰래해라ㅋㅋ 



### 2.5 리팩토링 관련 문제들 



1. 데이터베이스 

2. 인터페이스 변경 

3. 리팩토링을 어렵게 하는 설계를 수정하는 일 

4. 리팩토링을 하면 안되는 상황 



### 2.6 리팩토링과 설계 



간단한 솔루션을 구현해 놓고 그걸 나중에 유연한 솔루션으로 리팩토링 하려면 얼마나 수고가 들까? 를 고민해보고 웬만한 경우철머 별 어려움이 없을 것 같다면 간단한 솔루션을 구현하자. 심플한게 최고 



### 2.7 리팩토링과 성능 



리팩토링을 통해 프로그램을 잘 쪼개면 성능 튜닝에 할애할 시간이 생기고 성능을 분석할 때 더 정밀한 분석이 가능해져 길게보면 성능향상에 도움을 준다. 

단기적으로 소프트웨어가 느려지지만, 최적화를 거치면서 튜닝하기 훨씬 쉬워져 결과적으로는 소프트웨어 개발이 더 빨라진다. 



## 3. 코드의 구린내 



### 3.1 중복코드 



메서드 추출 / 메서드 상향 / 템플릿 메소드 형성 / 알고리즘 전환 / 주변 메소드 추출 / 클래스 추출 / 모듈 추출 



### 3.2 장황한 메소드 



메소드 추출 / 임시 변수를 메소드 호출로 전환 / 임시 변수를 메소드 체인으로 전환 / 매개변수를 세트 객체로 전환 / 객체를 통채로 전달 / 메소드를 메소드 객체로 전환 / 조건문 쪼개기 / 루프를 컬렉션 클로저 메소드로 전환 



### 3.3 방대한 클래스 



클래스 추출 / 하위 클래스 추출 / 모듈 추출 / 인터페이스 추출 



### 3.4 과다한 매개변수 



매개변수 세트를 메소드로 전환 / 객체를 통째로 전달 / 매개변수 세트를 객체로 전환 



### 3.5 수정의 산발 



한 클래스가 다양한 원인 때문에 다양한 방식으로 자주 수정될 때 -> 객체를 분리 



### 3.6 기능의 산재 



하나의 수정이 생길때마다 여러 클래스에서 수많은 자잘한 부분을 고쳐야 할 때. 수정의 산발과는 비슷하지만 정 반대다 



### 3.7 잘못된 소속 



객체의 핵심은 데이터와 그 데이터에 사용되는 프로세스를 한 데 묶는 기술 메서드 이동 / 메서드 추출 



### 3.8 데이터 뭉치 



데이터 뭉치를 클래스로 추출 한 뒤 매개변수 세트를 객체로 전환 / 객체를 통째로 전달 



### 3.9 강박적 기본 타입 사용 



데이터값을 객체로 전환 / 분류부호를 클래스 (하위클래스)로 전환 / 분류부호를 상태/전략 패턴으로 변환 



### 3.10 switch 문 



`switch` 문은 고민할 것 없이 다형성을 통한 재정의로 바꿔야한다. 



### 3.11 평행 상속 계층 



### 3.12 직무유기 클래스 



계층병합 / 클래스내용 직접 삽입 / 모듈 내용 직접 삽입 



### 3.13 막연한 범용 코드 



메서드나 클래스가 오로지 테스트 케이스에만 사용되고 있다면 의심해볼것 



### 3.14 임시필드 



객체안에 어떤 인스턴스 변수가 특정 상황에만 할당될 때 이는 헷갈림을 유발한다. 



### 3.15 메세지 체인 



대리객체 은폐 



### 3.16 과인 중개 메서드 



과잉 중개 메서드 제거 / 메서드 내용 직접 삽입 / 위임을 상속으로 변경 



### 3.17 지나친 관여 



메서드 이동 / 필드 이동 / 양방향 연결을 단방향으로 변경 / 클래스 추출 / 대리 객체 은폐 / 상속을 위임으로 전환 



### 3.18 인터페이스가 다른 대용 클래스 



### 3.19 미흡한 라이브러리 클래스 



외래클래스에 메소드 추가 / 국소적 상속 확장 클래스 사용 



### 3.20 데이터 클래스 



컬렉션 캡슐화 / 쓰기 메서드 제거 



### 3.21 방치된 상속물 



### 3.22 불필요한 주석 



어선셜 넣기 / 주석을 넣어야겠다는 생각이 들면 리팩토링을 통해 주석을 없앨 수는 없을지 고민해볼것 

